> 给一个二进制串，可以翻转若干次，翻转过程如下：  
可以选任意位置翻转，左右相邻的 1 个位置也翻转。  
翻转：0 变成 1，1 变成 0。  
例如：11011 在第三个位置翻转，就变成了 10101。  
若翻转在左右两侧，则只有右左相邻元素翻转。  
请找到翻转到所有位都是 0 的最小次数。  
输入描述：  
第一行输入一个整数 T，表示 T 组测试数据。  
接下来 T 行，每一行一个字符串 s，保证只有 0 和 1。  
1 <= T <= 100  
1 <= len(s) <= 20  
输出描述：pass

可以看做图的最短路径搜索问题。  
已知图的节点之间的转移方式，求某个起点开始，到特定的元素的最短路径（这里是全 0）。  
思路是：  
**BFS** 单步搜索相邻节点；  
**DFS** 搜索所有可能的范围；  
**贪心**决定单步搜索的顺序；  
设标志避免成**环**。