- [ ] Pytorch [Internals领读博客](http://blog.christianperone.com/2018/03/pytorch-internal-architecture-tour/)
    - [ ]  Introduction: pytorch build system introduction
    - [ ]  Pytorch extension: C++ 的扩展，用 Python Ref-Count 的引用管理
        - [ ] Python 所有都是对象 `a = 200; b = 200; a is b`，但是`a = 300; b = 300; a is not b`，因为 CPython Index 时，为避免重复创建 interger number 类，CPython 将 -5 到 256 的数字当做 Cache。
    - [ ] Numpy 与 Pytorch 的数据共享
        - [ ] torch.from_numpy 会对 numpy 的数据做引用。
        - [ ] 对 torch.tensor 类做 inplace 操作时，同样不会产生 copy。
    - [ ] Tensor Storage
        - [x] Storage 的对数据的封装，解耦了数据和读取格式，让 .view() 成为可能，实现 zero-copy。
    - [ ] Shared Memory 


- [ ] 阅读 pytorch 源码过程
    - [x] 根目录下 `CONTRIBUTING.md` 文件已经给出了一定文件结构的解释。
    - [x] Python 接口的探究，以 Dropout 为例：`torch/nn/modules/dropout.py -> torch/nn/functional.py -> torch/nn/_VF.py` 到此为止，Python的接口终止于 `_VF.py` 文件。值得一提的是，`torch/nn/modules/dropout.py` 很详细地描述了实现的操作，可以当做**文档**来看。
    - [x] _VF.py 对应的 C++ 接口：_VF类实际调用了 `torch._C._VariableFunctions` ，[有相关讨论](https://discuss.pytorch.org/t/where-to-find-torch-c-variablefunctions-module/41305)。
    - [ ] Dropout 的位置可能位于 `aten/src/ATen/naive`，也有可能位于 `torch/csrc`的前端。我觉着得看 C++了，再继续读下去很难理解。
    - [ ] 2019年5月的[文档说明：Pytorch-internals](https://archwalker.github.io/blog/2019/05/27/pytorch-internals.html)
        - [x] 为什么找不到上述 `torch._C._VariableFunctions`？ 因为这个文件是编译之后生成的！